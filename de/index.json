[{"categories":null,"content":"jQuery hat eine Funktion, die nur dazu bestimmt ist, die untergeordneten Elemente aus einem anderen Element zu entfernen. Die Methode „empty()“ kann direkt auf das Objekt angewendet werden.\nBetrachten Sie den folgenden HTML-Code.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Lorem ipsum dolor sit amet\u0026lt;/title\u0026gt; 5\u0026lt;/head\u0026gt; 6\u0026lt;body\u0026gt; 7 \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt; 8 \u0026lt;p\u0026gt;First paragraph\u0026lt;/p\u0026gt; 9 \u0026lt;p\u0026gt;Second paragraph\u0026lt;/p\u0026gt; 10 \u0026lt;p\u0026gt;Third paragraph\u0026lt;/p\u0026gt; 11 \u0026lt;p\u0026gt;Fourth paragraph\u0026lt;/p\u0026gt; 12 \u0026lt;/div\u0026gt; 13 \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 14\u0026lt;/body\u0026gt; 15\u0026lt;/html\u0026gt; Um alle Absätze innerhalb des „myDiv“-Elements zu entfernen, verwenden Sie einfach den folgenden Code in jQuery.\n1$(\u0026#34;#myDiv\u0026#34;).empty(); Aber wie können wir dieselbe Operation nur mit JavaScript ausführen?\nEntfernen von untergeordneten Elementen aus einem DOM-Knoten mit JavaScript\rJavaScript ermöglicht es dem Programmierer, über verschiedene Eigenschaften Elemente aus einem DOM-Knoten zu entfernen. Lassen Sie uns lernen, wie Sie diese Entfernung mit jedem von ihnen durchführen.\ninnerHTML\rEine dieser Eigenschaften ist „innerHTML“. Es ermöglicht das Ersetzen des gesamten internen HTML des Elements. Einschließlich der Ersetzung durch eine leere Zeichenfolge, wodurch das betreffende Element leer wird.\nUm alle untergeordneten Knoten innerhalb des „myDiv“-Elements zu entfernen, verwenden Sie das folgende JavaScript.\n1document.getElementById(\u0026#34;myDiv\u0026#34;).innerHTML = \u0026#34;\u0026#34;; Unten sehen Sie ein vollständiges Beispiel in HTML. Hier verwenden wir eine Schaltfläche, um Elemente zu entfernen.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Removing HTML elements using innerHTML\u0026lt;/title\u0026gt; 5 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;div id=\u0026#34;myDiv\u0026#34; style=\u0026#34;border: 3px dashed red; margin-bottom: 20px;\u0026#34;\u0026gt; 9 \u0026lt;p\u0026gt;First paragraph\u0026lt;/p\u0026gt; 10 \u0026lt;p\u0026gt;Second paragraph\u0026lt;/p\u0026gt; 11 \u0026lt;p\u0026gt;Third paragraph\u0026lt;/p\u0026gt; 12 \u0026lt;p\u0026gt;Fourth paragraph\u0026lt;/p\u0026gt; 13 \u0026lt;/div\u0026gt; 14 15 \u0026lt;button id=\u0026#39;removeElements\u0026#39;\u0026gt;Remove paragraphs (innerHTML)\u0026lt;/button\u0026gt; 16 17 \u0026lt;script\u0026gt; 18 const button = document.getElementById(\u0026#34;removeElements\u0026#34;); 19 button.onclick = function () { 20 document.getElementById(\u0026#34;myDiv\u0026#34;).innerHTML = \u0026#34;\u0026#34;; 21 }; 22 \u0026lt;/script\u0026gt; 23\u0026lt;/body\u0026gt; 24\u0026lt;/html\u0026gt; textContent\rMit der Eigenschaft „textContent“ können alle Elemente innerhalb eines Knotens durch einen leeren String ersetzt werden.\nJe nach Browser kann die Verwendung von „textContent“ besser abschneiden als „innerHTML“.\n1document.getElementById(\u0026#34;myDiv\u0026#34;).textContent = \u0026#34;\u0026#34;; Untergeordnete Elemente mit einer Schleife entfernen („lastChild“)\rIm folgenden Beispiel verwenden wir die „while“-Schleife, um zu prüfen, ob unser Element das erste untergeordnete Element enthält. Wenn es wahr ist, gibt es an, dass es mindestens ein untergeordnetes Element innerhalb des übergeordneten Elements gibt, sodass die Schleife das letzte Element entfernt. Und der Vorgang wiederholt sich.\nDas Entfernen des letzten Elements mit der Eigenschaft „lastChild“ ist normalerweise besser als das Entfernen des ersten Elements mit der Eigenschaft „firstChild“.\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.removeChild(element.lastChild); 4} Untergeordnete Elemente mit einer Schleife entfernen („lastElementChild“)\rHier erzielen wir das gleiche Ergebnis, behalten aber „Nicht-Elemente“ wie Textknoten „#text“ und Kommentare „\u0026lt;!\u0026ndash; comments \u0026ndash;\u0026gt;“ bei.\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.removeChild(element.lastElementChild); 4} Eine weitere Funktion von „lastElementChild“ besteht darin, untergeordnete Knoten innerhalb des übergeordneten Elements beizubehalten, die keine direkten Nachkommen sind.\nBetrachten Sie beispielsweise die Struktur der Elemente unten.\n1Parent element 2| 3 — First node 4| | 5| — Node 1 6| | 7| — Node 2 8| 9 — Second node Bei Verwendung von „lastElementChild“ würden „First node“ und „Second node“ entfernt. „Node 1“ und „Node 2“ würden nicht entfernt.\nEntfernen Sie untergeordnete Elemente mit der Methode „remove“.\r1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.lastChild.remove(); 4} Die Funktion „remove“ wurde in ES5 hinzugefügt. Es hat eine einfachere und direktere Verkettung Syntax. Es wird bereits von vielen Browsern hervorragend unterstützt\r.\nEntfernen Sie Elemente mit der Methode „replaceChildren“.\rEs besteht auch die Möglichkeit, mit der „replaceChildren“-API Kindelemente aus einem DOM-Knoten zu entfernen. Mit dieser Methode können Sie nicht nur Elemente aus einem übergeordneten Element entfernen, sondern sie auch durch andere Elemente in nur einem Vorgang ersetzen.\nUm nur die untergeordneten Elemente zu entfernen, rufen Sie die API ohne Argumente auf.\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2element.replaceChildren(); Die „replaceChildren“-API wird von modernen Browsern bereits gut unterstützt\r.\n","date":"05.03.2022","img":"","permalink":"https://w3source.org/de/articles/javascript-equivalent-to-jquery-empty/","series":null,"tags":["JavaScript","jQuery"],"title":"Vanilla-JavaScript-Code entspricht jQuery.empty()"},{"categories":null,"content":"Viele Benutzer haben Zweifel, wie sie mit jQuery überprüfen können, ob ein Element im HTML-DOM vorhanden ist. Kurz gesagt, wie kann man auf einfachste Weise überprüfen, ob ein Element auf der Seite vorhanden ist?\nEs gibt mehrere Möglichkeiten, wie wir dieses Ergebnis erzielen können. Eine davon besteht darin, zu prüfen, ob die Eigenschaft „Länge“ des Elements Elektors eine Zahl größer als 0 zurückgibt.\nZum Beispiel, wenn wir HTML ähnlich dem unten gezeigten haben.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Lorem ipsum dolor\u0026lt;/title\u0026gt; 5 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Lorem ipsum dolor sit amet.\u0026lt;/div\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Und wir wollen prüfen, ob das Element „myDiv“ im DOM existiert, d. h. auf der Seite können wir den folgenden Code verwenden.\n1if ($(\u0026#34;#myDiv\u0026#34;).length \u0026gt; 0) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Vereinfachung des Codes\rDa viele Dinge in JavaScript entweder wahr oder falsch sind, kann die Rückgabe der Eigenschaft „length“ ebenfalls als wahr oder falsch betrachtet werden. Die Rückgabe ist eine Zahl, 0 steht für „falsch“ und alles andere für „wahr“.\nWir können den Code also wie folgt vereinfachen.\n1if ($(\u0026#34;#myDiv\u0026#34;).length) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Auch wenn der Vergleich „\u0026gt; 0“ entfernt wird, bleibt der Rückgabewert gleich.\nErstellen einer „exists“-Funktion für jQuery\rWir können noch etwas weiter gehen und eine Funktion namens „exists“ hinzufügen. Diese Funktion kann direkt mit dem zu prüfenden Element verwendet werden.\n1jQuery.fn.exists = function() { 2 return ( $(this).length \u0026gt; 0); 3} 4 5var elementExists = $(\u0026#34;#myDiv\u0026#34;).exists(); 6 7console.log(elementExists); Wir können uns noch weiter verbessern und verhindern, dass das Verfahren eine Verkettung Möglichkeit darstellt. Was in diesem Fall nicht möglich ist. Wir werden es wie folgt tun.\n1jQuery.exists = function(selector) { 2 return ( $(selector).length \u0026gt; 0 ); 3} 4 5if ( $.exists(\u0026#34;#myDiv\u0026#34;) ) { 6 console.log(\u0026#34;The element exists!\u0026#34;); 7} Beachten Sie, dass wir jetzt den Selektor als Argument an die „exists“-Funktion übergeben, anstatt eine Kette direkt aus dem Objekt zu simulieren.\nÜberprüfen der Existenz eines HTML-Elements mit Array\rWenn wir einen Selektor in jQuery verwenden, gibt er ein Array von Elementen zurück. Wenn wir versuchen, auf das erste Element dieses Arrays zuzugreifen und es „undefiniert“ zurückgibt, zeigt dies an, dass das betreffende Element nicht im DOM existiert.\n1if ( $(\u0026#39;#myDiv\u0026#39;)[0] ) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Wie Sie sehen, gibt es mehrere Möglichkeiten, das Vorhandensein eines HTML-Elements auf der Seite zu überprüfen. Was ist das Beste? Nun, derjenige, der Ihr Problem löst. Das Wichtigste ist, dass Ihr Code ausgeführt wird und funktioniert.\n","date":"03.03.2022","img":"","permalink":"https://w3source.org/de/articles/is-there-an-exists-function-for-jquery/","series":null,"tags":["JavaScript","jQuery"],"title":"Gibt es in jQuery eine 'exists'-Funktion? (HTML-Element vorhanden?)"},{"categories":null,"content":"Die hasOwnProperty - Methode von JavaScript wird verwendet, um zu prüfen, ob ein bestimmtes Objekt eine bestimmte Eigenschaft hat.\nDie von der Methode hasOwnProperty geprüfte Eigenschaft ist objekt intern, dh sie muss vom Benutzer definiert worden sein.\nWenn die an hasOwnProperty übergebene Eigenschaft für das Objekt vorhanden ist, gibt die Methode true zurück , andernfalls gibt sie false zurück .\nBeispiel 1:\nIn diesem Beispiel erstellen wir das Objekt person und fügen die Eigenschaft name hinzu , dann verwenden wir hasOwnProperty , um zu überprüfen, ob diese Eigenschaft Teil unseres Objekts ist.\n1var person = { 2 \u0026#34;name\u0026#34;: \u0026#34;Brian\u0026#34;, 3 \u0026#34;lastName\u0026#34;: \u0026#34;Scott\u0026#34; 4}; 5 6console.log( person.hasOwnProperty(\u0026#34;name\u0026#34;) ); Ausgabe:\n1true Beispiel 2:\nIn diesem Beispiel werden wir ein Objekt namens car deklarieren und ihm eine Eigenschaft namens doors zuweisen , sodass wir hasOwnProperty verwenden können , um diese Eigenschaft zu überprüfen.\n1var car = { 2 \u0026#34;doors\u0026#34;: 4, 3 \u0026#34;engine\u0026#34;: 2.0, 4 \u0026#34;color\u0026#34;: \u0026#34;black\u0026#34; 5}; 6 7var hasDoor = car.hasOwnProperty(\u0026#34;doors\u0026#34;); 8 9console.log(hasDoor); Ausgabe:\n1true Beispiel 3:\nHier werden wir den Eigenschaftsnamen unseres Objekts absichtlich falsch schreiben, sodass die Methode hasOwnProperty false zurückgibt .\n1var shoppingCart = { 2 \u0026#34;fruits\u0026#34;: true, 3 \u0026#34;bread\u0026#34;: false 4}; 5 6var hasFruits = shoppingCart.hasOwnProperty(\u0026#34;fruites\u0026#34;); 7 8console.log(hasFruits); Ausgabe:\n1false Warum ist es wichtig, die hasOwnProperty-Methode zu verwenden?\rSehen wir uns an, wie wichtig es ist, die hasOwnProperty-Methode zu verwenden , um zu prüfen, ob eine Eigenschaft in einem Objekt in JavaScript vorhanden ist.\nAlles in JavaScript ist ein Objekt.\rRichtig, jedes in JavaScript erstellte Element wird als Objekt betrachtet. Zahlen, Text Zeichenfolgen, Arrays und alle anderen JavaScript-Datentypen erben Eigenschaften von einem übergeordneten Objekt.\nBeispiel 1:\nDer numerische Datentyp in JavaScript wird als Objekt betrachtet.\n1var number = 10.22333; 2var otherNumber = number.toPrecision(3); 3 4console.log(otherNumber); Ausgabe:\n110.2 Beispiel 2:\nDer Datentyp string wird ebenfalls als Objekt betrachtet.\n1var name = \u0026#34;Peter Max\u0026#34;; 2var char = name.charAt(2); 3 4console.log(char); Ausgabe:\n1t Beispiel 3:\nSogar Arrays in JavaScript sind Objekte.\n1var cars = [\u0026#34;BMW\u0026#34;, \u0026#34;Audi\u0026#34;, \u0026#34;Aston Martin\u0026#34;]; 2 3var carIndexNumber = cars.indexOf(\u0026#34;BMW\u0026#34;); 4 5console.log(carIndexNumber); Ausgabe:\n10 In den vorherigen Beispielen erben alle Objekte Eigenschaften vom Hauptobjekt Object.\nDer in-Befehl in JavaScript\rNeue JavaScript-Programmierer verwenden normalerweise den Befehl in , um zu prüfen, ob eine Eigenschaft für ein bestimmtes Objekt vorhanden ist.\nBeispiel:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if (\u0026#34;engine\u0026#34; in car) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Ausgabe:\n1true Das Problem ist, dass der Befehl in umfassend ist. Es wird nach allen Eigenschaften des Objekts gesucht. Benutzerdefinierte Eigenschaften und Eigenschaften, die vom übergeordneten Objekt geerbt wurden, werden in die Prüfung einbezogen.\nDies kann zu einem Logikfehler führen, wenn der Programmierer einen Codeabschnitt nur dann ausführt, wenn eine Objekt Eigenschaft vorhanden ist.\nAber der Programmierer möchte eine Standardeigenschaft des Objekts überprüfen? Oder eine vom Benutzer erstellte Eigenschaft?\nBeispiel:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if (\u0026#34;toString\u0026#34; in car) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Ausgabe:\n1true Im vorherigen Beispiel gibt der Befehl in true zurück , das heißt, er geht davon aus, dass die Eigenschaft toString in unserem Objekt vorhanden ist, obwohl diese Eigenschaft nicht von uns deklariert wurde.\nDie Eigenschaft/Methode toString wird vom übergeordneten Objekt geerbt. Um diese Verwirrung zu vermeiden, verwenden Sie immer die hasOwnProperty- Methode .\nBeispiel:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if ( car.hasOwnProperty(\u0026#34;toString\u0026#34;) ) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Ausgabe:\n1false Jetzt war die Rückgabe der Wert false. Das liegt daran, dass die hasOwnProperty-Methode , wie wir bereits gesehen haben, nur nach benutzerdefinierten Eigenschaften sucht.\n","date":"25.02.2022","img":"","permalink":"https://w3source.org/de/articles/javascript-hasownproperty/","series":null,"tags":["JavaScript"],"title":"Erfahren Sie, wie Sie die hasOwnProperty()-Methode von JavaScript verwenden"}]