[{"categories":null,"content":"jQuery имеет функцию, предназначенную только для удаления дочерних элементов внутри другого элемента. Метод «empty()» можно использовать непосредственно на объекте.\nРассмотрим приведенный ниже HTML-код.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Lorem ipsum dolor sit amet\u0026lt;/title\u0026gt; 5\u0026lt;/head\u0026gt; 6\u0026lt;body\u0026gt; 7 \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt; 8 \u0026lt;p\u0026gt;First paragraph\u0026lt;/p\u0026gt; 9 \u0026lt;p\u0026gt;Second paragraph\u0026lt;/p\u0026gt; 10 \u0026lt;p\u0026gt;Third paragraph\u0026lt;/p\u0026gt; 11 \u0026lt;p\u0026gt;Fourth paragraph\u0026lt;/p\u0026gt; 12 \u0026lt;/div\u0026gt; 13 \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 14\u0026lt;/body\u0026gt; 15\u0026lt;/html\u0026gt; Чтобы удалить все абзацы внутри элемента «myDiv», просто используйте следующий код в jQuery.\n1$(\u0026#34;#myDiv\u0026#34;).empty(); Но как мы можем выполнить ту же операцию, используя только JavaScript?\nУдаление дочерних элементов из узла DOM с помощью JavaScript\rJavaScript позволяет программисту удалять элементы из узла DOM с помощью различных свойств. Давайте узнаем, как сделать это удаление, используя каждый из них.\ninnerHTML\rОдним из таких свойств является «innerHTML». Это позволяет заменить весь внутренний HTML-код элемента. В том числе для замены пустой строкой, что делает рассматриваемый элемент пустым.\nЧтобы удалить все дочерние узлы внутри элемента «myDiv», используйте следующий код JavaScript.\n1document.getElementById(\u0026#34;myDiv\u0026#34;).innerHTML = \u0026#34;\u0026#34;; Ниже вы можете увидеть полный пример в HTML. Здесь мы используем кнопку для удаления элементов.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Removing HTML elements using innerHTML\u0026lt;/title\u0026gt; 5 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;div id=\u0026#34;myDiv\u0026#34; style=\u0026#34;border: 3px dashed red; margin-bottom: 20px;\u0026#34;\u0026gt; 9 \u0026lt;p\u0026gt;First paragraph\u0026lt;/p\u0026gt; 10 \u0026lt;p\u0026gt;Second paragraph\u0026lt;/p\u0026gt; 11 \u0026lt;p\u0026gt;Third paragraph\u0026lt;/p\u0026gt; 12 \u0026lt;p\u0026gt;Fourth paragraph\u0026lt;/p\u0026gt; 13 \u0026lt;/div\u0026gt; 14 15 \u0026lt;button id=\u0026#39;removeElements\u0026#39;\u0026gt;Remove paragraphs (innerHTML)\u0026lt;/button\u0026gt; 16 17 \u0026lt;script\u0026gt; 18 const button = document.getElementById(\u0026#34;removeElements\u0026#34;); 19 button.onclick = function () { 20 document.getElementById(\u0026#34;myDiv\u0026#34;).innerHTML = \u0026#34;\u0026#34;; 21 }; 22 \u0026lt;/script\u0026gt; 23\u0026lt;/body\u0026gt; 24\u0026lt;/html\u0026gt; textContent\rСвойство textContent можно использовать для замены всех элементов внутри узла пустой строкой.\nВ зависимости от браузера использование «textContent» может работать лучше, чем «innerHTML».\n1document.getElementById(\u0026#34;myDiv\u0026#34;).textContent = \u0026#34;\u0026#34;; Удалить дочерние элементы с помощью цикла («lastChild»)\rВ приведенном ниже примере мы используем цикл «while», чтобы проверить, содержит ли наш элемент первый дочерний элемент. Если это правда, это указывает, что внутри родительского элемента есть по крайней мере один дочерний элемент, поэтому цикл удаляет последний элемент. И процесс повторяется.\nУдаление последнего элемента с использованием свойства lastChild обычно работает лучше, чем удаление первого элемента с использованием свойства firstChild.\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.removeChild(element.lastChild); 4} Удалить дочерние элементы с помощью цикла («lastElementChild»)\rЗдесь мы добьемся того же результата, но сохраним «не-Элементы», такие как текстовые узлы «#text» и комментарии «\u0026lt;!\u0026ndash; comments \u0026ndash;\u0026gt;».\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.removeChild(element.lastElementChild); 4} Другая особенность «lastElementChild» заключается в сохранении дочерних узлов внутри родительского элемента, которые не являются прямыми потомками.\nНапример, рассмотрим структуру элементов ниже.\n1Parent element 2| 3 — First node 4| | 5| — Node 1 6| | 7| — Node 2 8| 9 — Second node При использовании «lastElementChild» «First node» и «Second node» будут удалены. «Node 1» и «Node 2» не будут удалены.\nУдалить дочерние элементы методом «remove»\r1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2while (element.firstChild) { 3 element.lastChild.remove(); 4} Функция «remove» была добавлена ​​в ES5. Он имеет более простой и прямой синтаксис цепочки. Он уже имеет отличную поддержку во многих браузерах\r.\nУдалить элементы методом «replaceChildren»\rСуществует также возможность удалить дочерние элементы из узла DOM с помощью API replaceChildren. Этот метод позволяет не только удалять элементы из родительского элемента, но и заменять их другими элементами всего за одну операцию.\nЧтобы просто удалить дочерние элементы, вызовите API без аргументов.\n1const element = document.getElementById(\u0026#34;myDiv\u0026#34;); 2element.replaceChildren(); API «replaceChildren» уже хорошо поддерживается современными браузерами\r.\n","date":"05.03.2022","img":"","permalink":"https://w3source.org/ru/articles/javascript-equivalent-to-jquery-empty/","series":null,"tags":["JavaScript","jQuery"],"title":"Ванильный код JavaScript, эквивалентный jQuery.empty()"},{"categories":null,"content":"Многие пользователи сомневаются, как проверить, существует ли элемент в HTML DOM с помощью jQuery. В двух словах, как проверить наличие элемента на странице самым простым способом?\nЕсть несколько способов, которые мы можем использовать для достижения этого результата. Один из них — проверить, возвращает ли свойство «длина» селектора элемента число больше 0.\nНапример, если у нас есть HTML, подобный показанному ниже.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Lorem ipsum dolor\u0026lt;/title\u0026gt; 5 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;Lorem ipsum dolor sit amet.\u0026lt;/div\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; И мы хотим проверить, существует ли элемент «myDiv» в DOM, т.е. на странице мы можем использовать следующий код.\n1if ($(\u0026#34;#myDiv\u0026#34;).length \u0026gt; 0) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Упрощение кода\rПоскольку многие вещи в JavaScript либо истинны, либо ложны, возврат свойства «длина» также может считаться истинным или ложным. Возвращаемое значение — это число, 0 означает «ложь», а все остальное — «истина».\nТаким образом, мы можем упростить код следующим образом.\n1if ($(\u0026#34;#myDiv\u0026#34;).length) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Даже удалив сравнительный «\u0026gt; 0», возвращаемое значение останется прежним.\nСоздание функции «существует» для jQuery\rМы можем пойти немного дальше и добавить функцию с именем «exists». Эту функцию можно использовать непосредственно с элементом, который мы хотим проверить.\n1jQuery.fn.exists = function() { 2 return ( $(this).length \u0026gt; 0); 3} 4 5var elementExists = $(\u0026#34;#myDiv\u0026#34;).exists(); 6 7console.log(elementExists); Мы можем еще больше улучшить и не допустить, чтобы метод представлял возможность цепочки. Что в данном случае невозможно. Мы сделаем это следующим образом.\n1jQuery.exists = function(selector) { 2 return ( $(selector).length \u0026gt; 0 ); 3} 4 5if ( $.exists(\u0026#34;#myDiv\u0026#34;) ) { 6 console.log(\u0026#34;The element exists!\u0026#34;); 7} Обратите внимание, что теперь мы передаем селектор в качестве аргумента функции «существует» вместо того, чтобы имитировать цепочку непосредственно из объекта.\nПроверка существования элемента HTML с помощью массива\rКогда мы используем селектор в jQuery, он возвращает массив элементов. Если мы попытаемся получить доступ к первому элементу этого массива, и он вернет «undefined», это означает, что рассматриваемый элемент не существует в DOM.\n1if ( $(\u0026#39;#myDiv\u0026#39;)[0] ) { 2 console.log(\u0026#34;The element exists!\u0026#34;); 3} Как видите, существует несколько способов проверить наличие HTML-элемента на странице. Что самое лучшее? Ну, тот, который решит вашу проблему. Важно то, что ваш код работает и работает.\n","date":"03.03.2022","img":"","permalink":"https://w3source.org/ru/articles/is-there-an-exists-function-for-jquery/","series":null,"tags":["JavaScript","jQuery"],"title":"Есть ли функция «exists» в jQuery? (элемент HTML существует?)"},{"categories":null,"content":"Метод JavaScript hasOwnProperty используется для проверки того, имеет ли данный объект определенное свойство.\nСвойство, проверяемое методом hasOwnProperty, является внутренним для рассматриваемого объекта, то есть оно должно быть определено пользователем.\nЕсли свойство, переданное hasOwnProperty, существует в объекте, метод возвращает true, в противном случае он возвращает false .\nПример 1:\nВ этом примере мы создаем объект человека и добавляем свойство name, затем мы используем hasOwnProperty, чтобы убедиться, что это свойство является частью нашего объекта.\n1var person = { 2 \u0026#34;name\u0026#34;: \u0026#34;Brian\u0026#34;, 3 \u0026#34;lastName\u0026#34;: \u0026#34;Scott\u0026#34; 4}; 5 6console.log( person.hasOwnProperty(\u0026#34;name\u0026#34;) ); Выход:\n1true Пример 2:\nВ этом примере мы собираемся объявить объект с именем car и присвоить ему свойство с именем door, поэтому мы можем использовать hasOwnProperty для проверки этого свойства.\n1var car = { 2 \u0026#34;doors\u0026#34;: 4, 3 \u0026#34;engine\u0026#34;: 2.0, 4 \u0026#34;color\u0026#34;: \u0026#34;black\u0026#34; 5}; 6 7var hasDoor = car.hasOwnProperty(\u0026#34;doors\u0026#34;); 8 9console.log(hasDoor); Выход:\n1true Пример 3:\nЗдесь мы намеренно напишем имя свойства нашего объекта с ошибкой, чтобы метод hasOwnProperty возвращал false .\n1var shoppingCart = { 2 \u0026#34;fruits\u0026#34;: true, 3 \u0026#34;bread\u0026#34;: false 4}; 5 6var hasFruits = shoppingCart.hasOwnProperty(\u0026#34;fruites\u0026#34;); 7 8console.log(hasFruits); Выход:\n1false Почему важно использовать метод hasOwnProperty?\rДавайте рассмотрим важность использования метода hasOwnProperty для проверки существования свойства внутри объекта в JavaScript.\nВсе в JavaScript является объектом.\rПравильно, любой элемент, созданный в JavaScript, считается объектом. Числа, текстовые строки, массивы и любые другие типы данных JavaScript наследуют свойства родительского объекта.\nПример 1:\nЧисловой тип данных в JavaScript считается объектом.\n1var number = 10.22333; 2var otherNumber = number.toPrecision(3); 3 4console.log(otherNumber); Выход:\n110.2 Пример 2:\nСтроковый тип данных также считается объектом.\n1var name = \u0026#34;Peter Max\u0026#34;; 2var char = name.charAt(2); 3 4console.log(char); Выход:\n1t Пример 3:\nДаже массивы в JavaScript являются объектами.\n1var cars = [\u0026#34;BMW\u0026#34;, \u0026#34;Audi\u0026#34;, \u0026#34;Aston Martin\u0026#34;]; 2 3var carIndexNumber = cars.indexOf(\u0026#34;BMW\u0026#34;); 4 5console.log(carIndexNumber); Выход:\n10 В предыдущих примерах все объекты наследуют свойства основного объекта Object.\nКоманда «in» в JavaScript\rНовые программисты JavaScript обычно используют команду in, чтобы проверить, существует ли свойство для данного объекта.\nПример:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if (\u0026#34;engine\u0026#34; in car) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Выход:\n1true Проблема в том, что команда in является исчерпывающей. Он будет выполнять поиск по всем свойствам объекта. В проверку включаются созданные пользователем свойства и свойства, унаследованные от родительского объекта.\nЭто может вызвать логическую ошибку, если программист запустит часть кода, только если свойство объекта существует.\nНо программист хочет проверить свойство объекта по умолчанию? Или свойство, созданное пользователем?\nПример:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if (\u0026#34;toString\u0026#34; in car) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Выход:\n1true В предыдущем примере команда in возвращает true, то есть предполагает, что свойство toString существует в нашем объекте, хотя это свойство нами не было объявлено.\nСвойство/метод toString наследуется от родительского объекта. Чтобы избежать этой путаницы, всегда используйте метод hasOwnProperty .\nПример:\n1var car = { 2 \u0026#34;doors\u0026#34;: 2, 3 \u0026#34;engine\u0026#34;: 1.2, 4 \u0026#34;color\u0026#34;: \u0026#34;yellow\u0026#34; 5}; 6 7if ( car.hasOwnProperty(\u0026#34;toString\u0026#34;) ) { 8 console.log(\u0026#34;true\u0026#34;); 9} else { 10 console.log(\u0026#34;false\u0026#34;); 11} Выход:\n1false Теперь возвращаемым значением было значение false . Это связано с тем, что, как мы видели ранее, метод hasOwnProperty ищет только определенные пользователем свойства.\n","date":"25.02.2022","img":"","permalink":"https://w3source.org/ru/articles/javascript-hasownproperty/","series":null,"tags":["JavaScript"],"title":"Узнайте, как использовать метод JavaScript hasOwnProperty"}]